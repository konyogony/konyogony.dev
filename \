'use client';
import { useState, useEffect, useRef, useCallback } from 'react';
import { cn } from '@/lib/utils';

interface KittyTerminalData {
    id: string;
    colSpan: number;
    rowSpan: number;
    shape: 'horizontal' | 'vertical';
    onHover: (id: string) => void;
}

const KittyTerminalComponent = ({ rowSpan, colSpan, id, onHover }: KittyTerminalData) => {
    return (
        <section
            className={cn(
                'flex h-full w-full flex-col rounded-xl bg-black/60 brightness-75 backdrop-blur-md transition-all duration-300 ease-in-out hover:brightness-100',
            )}
            data-id={id}
            tabIndex={0}
            style={{
                gridRow: `span ${rowSpan} / span ${rowSpan}`,
                gridColumn: `span ${colSpan} / span ${colSpan}`,
            }}
            onMouseEnter={() => onHover(id)}
            onFocus={() => onHover(id)}
            id={id}
        >
            <pre className='overflow-x-auto p-4 font-mono text-xs whitespace-pre text-blue-300'>
                {`
                ╭─kony@ogony ~ 
                ╰─$ ${id}`}
            </pre>
        </section>
    );
};

const wallpaper = 'https://github.com/konyogony/dotfiles/blob/main/.config/hypr/wallpaper.jpg?raw=true';

const Home = () => {
    const currentActiveTerminalID = useRef<string | null>(null);
    const onHover = useCallback((id: string) => {
        currentActiveTerminalID.current = id;
    }, []);

    const initialTerminals = useRef<KittyTerminalData[] | null>(null);

    if (initialTerminals.current === null) {
        initialTerminals.current = [
            {
                colSpan: 8,
                rowSpan: 4,
                shape: 'horizontal',
                id: crypto.randomUUID(),
                onHover,
            },
        ];
    }

    const [currentTerminals, setCurrentTerminals] = useState<KittyTerminalData[]>(
        // The state is initialized from the ref, which now contains our stable initial data.
        initialTerminals.current,
    );

    useEffect(() => {
        const handler = (e: KeyboardEvent) => {
            const ctrl = e.ctrlKey || e.metaKey;
            const shift = e.shiftKey;

            const key = e.key.toLowerCase();
            const keys = ['z', 'w', 't'];
            if (ctrl) {
                if (key === 't') {
                    e.preventDefault();
                    setCurrentTerminals((prev) => {
                        const currentActiveTerminal = prev.find(
                            (terminal) => terminal.id === (currentActiveTerminalID.current ?? '0'),
                        );

                        // Return previous state if no active terminal is found, instead of crashing.
                        if (!currentActiveTerminal) return prev;

                        const isHorizontal = currentActiveTerminal.shape === 'horizontal';
                        const newShape = isHorizontal ? 'vertical' : 'horizontal';

                        if (isHorizontal) {
                            // Prevent splitting a terminal that is already at minimum width
                            if (currentActiveTerminal.colSpan < 2) return prev;
                            currentActiveTerminal.colSpan /= 2;
                        } else {
                            // Prevent splitting a terminal that is already at minimum height
                            if (currentActiveTerminal.rowSpan < 2) return prev;
                            currentActiveTerminal.rowSpan /= 2;
                        }

                        currentActiveTerminal.shape = newShape;

                        const newTerminal: KittyTerminalData = {
                            shape: newShape,
                            colSpan: currentActiveTerminal.colSpan,
                            rowSpan: currentActiveTerminal.rowSpan,
                            id: crypto.randomUUID(),
                            onHover,
                        };

                        const updated = [
                            ...prev.filter((terminal) => terminal.id !== currentActiveTerminal.id),
                            currentActiveTerminal,
                            newTerminal,
                        ];

                        // Removed localStorage persistence logic
                        return updated;
                    });
                }
                if (keys.includes(key)) {
                    e.preventDefault();
                }
                if (shift && key === 't') e.preventDefault();
                if (shift && ['arrowleft', 'arrowdown', 'arrowup', 'arrowright'].includes(key)) {
                    e.preventDefault();
                }
            }
        };

        window.addEventListener('keydown', handler);

        return () => window.removeEventListener('keydown', handler);
    }, [onHover]);

    return (
        <div
            className='relative grid min-h-screen w-full grid-cols-8 grid-rows-4 overflow-clip p-3'
            style={{
                backgroundImage: `url(${wallpaper})`,
                backgroundSize: 'cover',
                backgroundPosition: 'center',
                backgroundRepeat: 'no-repeat',
            }}
        >
            {currentTerminals.map((props, i) => (
                <KittyTerminalComponent {...props} key={i} />
            ))}
            <div className='absolute inset-0 z-20 flex h-fit w-fit flex-col items-start text-white'>
                <button onClick={() => console.log(1)}>Add Terminal</button>
                <button onClick={() => console.log(currentTerminals)}>Log</button>
                <button
                    onClick={() => {
                        // Reset to the initial state stored in the ref, without interacting with localStorage.
                        if (initialTerminals.current) {
                            setCurrentTerminals(initialTerminals.current);
                        }
                    }}
                >
                    clear
                </button>
            </div>
        </div>
    );
};

export default Home;
